### CSS 相关

<details>
  <summary>CSS 选择器有哪些</summary>

  分类可分三种：基本选择器、属性选择器、伪类选择器
  常用：class / id / 伪类 / 伪元素 / 属性

</details>

<details>
  <summary>盒子模型</summary>

  | 盒子模型 | 宽度计算 | CSS 设置 |
  | -- | -- | -- |
  | 标准 | `width = content-width` | box-sizing: content-box |
  | IE | `width = content-width + padding-width + border-width` | box-sizing: border-box |

</details>

<details>
  <summary>移动端适配 1px  问题</summary>

  Retina 屏幕像素比为 2，CSS 1px 会被渲染成 2px 的物理像素。

  解决方案：伪类 + transform 实现

  单边框：
  ```stylus
  border-1px($color) {
    position: relative
      &:after {
      display: block
      position: absolute
      left: 0
      bottom: 0
      width: 100%
      border-top: 1px solid $color
      content: ' '
    }
  }
  @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) {
    .border-1px {
       &::after {
        -webkit-transform: scaleY(0.7)
        transform: scaleY(0.7)
       }
    }
  }

  @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) {
    .border-1px {
      &::after {
       -webkit-transform: scaleY(0.5)
        transform: scaleY(0.5)
      }
    }
  }
  ```

  多边框：伪类宽高 200%，绝对定位 -50%，同等缩放实现。

</details>

<details>
  <summary>b 和 strong 的区别</summary>

  两者都有加粗字体的作用，但 strong 带有语义，表示强调，利于SEO。

</details>

<details>
  <summary>隐藏页面元素的方法有哪些？</summary>

  隐藏类型：
  1. 完全隐藏：从渲染树消失，不占据空间
  2. 视觉隐藏：仍占据控件，只是视屏中不显示
  3. 语义隐藏：阅读软件不可读，但正常占据空间

  #### 完全隐藏

  ##### display
  `display: none`

  ##### hidden 
  HTML5 新增属性，相当于 display: none
  `<div hidden></div>

  #### 视觉隐藏
  
  ##### position 移出可视区
  ```
  position: absolute;
  left: -99999px;
  ```


  #### 语义隐藏

  `<div aria-hidden="true"></div>`

</details>

<details>
  <summary>三栏布局/圣杯布局/双飞翼布局方式</summary>

  | 布局 | 优缺点 |
  | -- | -- |
  | float 浮动 | 脱离文档流，需清浮解决父层高度塌陷 |
  | absoulute 绝对定位 | 自身跟后代元素都脱离文档流，需定高 |
  | table 表格 | 兼容性好，高度统一撑开，无法设置边距，SEO不友好 |
  | flex | 较完美，IE10开始支持（-ms) |
  | grid 网格 | IE10+支持，没有内容结构，子元素可自行定义位置 |

  #### 1. float 浮动布局
  **`DOM` 结构先写浮动部分，再写中间，否则右浮动会掉到下一行**

  * 优点：简单，兼容性好
  * 缺点：脱离文档流，父层高度塌陷需清浮解决

  ```html
  <article>
      <div class="left red"></div>
      <div class="right blue"></div>
      <div class="center yellow"></div>
  </article>

  <style>
      .left {
          float: left;
          width: 300px;
      }
      .right {
          float: right;
          width: 300px;
      }
  </style>
  ```
  #### 2. absoulute 绝对定位布局
  * 优点：方便稳定
  * 脱离文档流，后代元素也脱离文档流，高度未知时，会有问题

  ```html
  <article>
    <div class="left red"></div>
    <div class="center yellow"></div>
    <div class="right blue"></div>
  </article>

  <style>
    article {
        position: relative;
    }
    article div {
        position: absolute;
    }
    .left {
        left: 0;
        width: 300px;
    }
    .right {
        right: 0;
        width: 300px;
    }
    .center {
        left: 300px;
        right: 300px;
    }
  </style>
  ```

  #### 3. table 表格布局
  * 优点：兼容性好
  * 缺点：
      * 无法设置栏边距；
      * 对 SEO 不友好；
      * 单元格高度超出时，两侧单元格高度会一并变高；
      
  ```html
  <article>
      <div class="left red"></div>
      <div class="center yellow"></div>
      <div class="right blue"></div>
  </article>

  <style>
      article {
          display: table;
      }
      article > div {
          display: table-cell;
      }
      .left, .right {
          width: 300px;
      }
  </style>
  ```
  #### 4. flex 布局
  * 优点：比较完美
  * 缺点：低版本浏览器兼容问题，IE10开始支持（-ms)

  ```html
  <article>
      <div class="left red"></div>
      <div class="center yellow"></div>
      <div class="right blue"></div>
  </article>

  <style>
      article {
          display: flex;
      }
      .left, .right {
          width: 300px;
      }
      .center {
          flex: 1;
      }
  </style>
  ```

  #### 5. grid 网格布局

  CSS3 推出的网格布局，按列或行对其排列，不同于表格，没有内容结构。子元素可定位自己的位置，可以重叠（IE10+支持）。

  ```
  article {
    display: grid;
    grid-template-columns: 300px auto 300px;
  }
  ```
</details>

<details>
  <summary>rem 与 flex 的区别</summary>
</details>

<details>
  <summary>em 与 px 的区别</summary>
</details>

<details>
  <summary>CSS3 position 新增支持 / position: sticky</summary>

  | 属性 | 作用 |
  | -- | -- |
  | static | 没有定位（默认 |
  | relative | 相对定位 | 
  | absolute | 绝对定位 |
  | fixed | 固定定位（相对body) |
  | sticky | 粘滞定位 | 

  1. absolute 会被 relative/absolute 的父元素限制，否则被 body
  2. stick 是 relative 和 fixed 的混合体
    * 元素在视口内，top/left 无效；
    * 滚动超出时，表现像 fixed；
    * left/right 同时设置保留前者，top/bottom 同理

</details>

<details>
  <summary>CSS 水平垂直居中的方式</summary>

  居中元素固定宽高：
  1. absolute + 负 margin
  2. absolute + margin auto
  3. absolute + calc

  居中元素不定宽：
  1. absolute + transform（移动端优先）
  2. line-height
  3. writing-mode
  4. table (可弃用)
  5. css-table
  6. flex（优先）
  7. grid

</details>

<details>
  <summary>居中为何优先使用 transform （而不用 margin/top)</summary>

  支持居中元素不用定宽，不用计算宽高减半值。

</details>

### JavaScript 相关

<details>
  <summary>JavaScript 中假值有哪些？</summary>

  JavaScript 中只有 6 个假值：`undefined/null/NaN/0/''/false`，包装对象类型都是真值（`new Number(0) / new Boolean(false)`)。
</details>

<details>
  <summary>类型判断</summary>

  1. `typeof` 只能用于基本类型判断，无法判断 `null`；
  2. `instanceof` 用于判断引用类型，缺点是 `null`；
  3. `Object.prototype.toString.call()` 较好的类型判断方式；
  4. `isPrototypeOf` ES6 新增的原型判断

  思路：先 `instanceof` 判断是不是复杂类型，再用 `typeof` 判断基本类型
  [正确的类型判断](https://github.com/YvetteLau/Blog/blob/master/JS/data-type.js)

</details>

<details>
  <summary>判断变量是不是数组</summary>

  1. ES6 `Array.isArray()` 返回 `true` 是；
  2. ES6 `Array.prototype.isPrototypeOf([])` 值为 `true` 是；
  3. `instanceof Array` 返回 `true` 是；
  4. `Object.prototype.toString.call()` 值为 `[object Array]` 是

</details>

<details>
  <summary>类数组和数组的区别</summary>

  类数组是一个普通对象，有 `length` 属性，而真实的数组是 `Array` 类型，且不具备数组的方法。

  常见类数组：
  1. 函数参数 `arguments`；
  2. DOM 对象列表 `document.querySelectorAll('li')`
  3. jQuery 对象 `$('div')`

  类数组转数组：
  ```
  // e.g.1
  Array.prototype.slice.call(arrLike);

  // e.g.2
  [...arrLike];

  // e.g.3
  Array.from(arrLike); 
  ```

  拥有遍历器接口的对象，都可用扩展运算符 `...` 和 `Array.from` 转为数组。

</details>

<details>
  <summary>表达式和语句的区别</summary>

  * 表达式：产生一个值
  * 语句：执行一个操作
  * 表达式语句：产生一个值和执行一个操作

</details>

<details>
  <summary>for of, for in 和 forEach, map的区别</summary>

  * for...of：遍历具有 itertaor 接口对象，包括数组、Set、Map、类数组对象、字符串，可中断循环
  * for...in：遍历对象自身和继承的可枚举的属性，不能直接获取属性值，可中断循环
  * forEach：只能遍历数组，没有返回值，不能中断
  * map：只能遍历数组，返回值是修改后的新数组，不能中断
</details>

<details>
  <summary>for...in 和 Object.keys() 的区别</summary>

  1. `Object.keys()` 返回自身可枚举属性组成的数组，顺序与 `for...in` 一致；
  2. `for...in` 除了遍历自身可枚举，还可以枚举原型链中属性

  记忆点：与 in 有关都会检索原型链
</details>

<details>
  <summary>== 和 === 的区别</summary>

  * `===` 全等运算符不需要类型转换，比较类型和值都相等时，返回 `true`；
  * `==` 类型不同，需先进行转换，如下
    * 判断是否为 `null` 或 `undefined`，是返回 `true`
    * 判断是否为 `string` 或 `number`，是字符串转 `number` 再比对
    * 判断其中一方是否为 `boolean`，是转为 `number` 再比对
    * 判断其中一方为 `object` 另一方为 `string/number/symbol`，是将 `object` 转原始类型再比对，调用 `toString()/valueOf()`

</details>

<details>
  <summary>Object.is() 与 === 的区别</summary>

  `Object.is()` 与 `===` 类似，有两点区别:
  1. `Object.is()` 判断 `NaN` 时，返回 `true`；
  2. `Object.is()` 判断 `+0/-0` 时，返回 `false`

  ```js
  Object.is(NaN, NaN);  // true
  Object.is(+0, -0);    // false

  NaN === NaN;          // false
  +0 === -0;            // true
  ```

</details>


<details>
  <summary>[] == ![]</summary>

  1. 优先级 `!` 高于 `==`
  2. `![]`，`object` 转为 `boolean` 为 `true`，因此这里为 `false`
  3. 其中一方为 `boolean`，先将 `boolean` 转为 `number`，0
  4. 其中一方为 `number`, `object` 类型转原始类型（空数组转数字为 0，若数组中仅有一个数字，转数字时就是该数字，其它情况为 `NaN`
  5. `0 == 0` 为 `true`

  [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

</details>

<details>
  <summary>ES6 中的 Class 类和 ES5 的类区别</summary>

  1. 定义的方法不可枚举；
  2. 必须使用 new 实例化；
  3. 不存在变量提升；
  4. 默认即是严格模式；
  5. 子类构造函数必须通过 `super()` 调用父类构造函数实现继承，才有 `this` 对象

  (ES5 中先有子类的 `this`, 再将父类的属性应用在 `this` 上);
  Class 类中用 `static` 声明的方法为静态方法，仅在构造函数中使用，不能传递给任何子类和实例对象。

</details>

<details>
  <summary>数组 API 中纯与不纯的函数</summary>

  不纯函数，会修改原数组：
  `splice/reverse/fill/copyWithin/sort/push/pop/unshift/shift`

  纯函数，不会修改原数组：
  `slice/map/forEach/every/filter/reduce/entries/find`

</details>

<details>
  <summary>判断 this 指向，箭头函数的 this</summary>

  this 绑定：默认绑定、隐式绑定、显示绑定、new绑定
  
  1. `new` 绑定，构造函数没有返回，`this` 指向新创建对象，若有返回，指向返回对象
  2. 显示绑定，通过 `apply/call/bind`，`this` 指向传入对象，如果传入对象为 `null/undefined`，则应用默认绑定规则
  3. 隐式绑定，取决与上下文对象调用者，指向该对象，`obj.foo()`
  4. 默认绑定，以上规则不匹配时，严格模式指向 `undefined`，否则指向全局对象
  5. 箭头函数, `this`取决于词法作用域，在函数声明时就确定，来自上一层代码块的 `this`

</details>

<details>
  <summary>实现 this 对象的深拷贝</summary>
</details>

<details>
  <summary>浏览器事件流向</summary>

</details>

<details>
  <summary>事件代理以及优缺点</summary>
  
  优点：
  1. 减少事件函数注册，仅绑定一个函数，节省内存；
  2. 支持动态绑定事件，针对动态列表元素，不用频繁绑定和解绑

  缺点：
  1. 基于冒泡和捕获实现，不支持冒泡和捕获的事件不支持；
  2. 层级过多时，若中间层阻止，可能无法到达事件元素，建议就近委托

  不支持冒泡的事件：`load/unload/scroll/resize/blur/focus/mouseleave/mouseenter/自定义事件`

</details>

<details>
  <summary>闭包特权函数的使用场景</summary>
</details>

<details>
  <summary>尾调用优化</summary>

  通过 return 优化

</details>

<details>
  <summary>函数参数是按值传递还是按引用传递</summary>

  函数参数是按值传递，引用类型的值是其栈中存储的值，一个地址指针。

</details>

<details>
  <summary>defineProperty 的应用场景</summary>
</details>

<details>
  <summary>setInterval 的注意点</summary>
</details>

<details>
  <summary>setTimeout(1) 和 setTimeout(2) 的区别</summary>

  setTimeout 最小时间是 400， 即 4 毫秒
</details>

<details>
  <summary>实现继承的方案</summary>
</details>

<details>
  <summary>变量 a, b 如何交换值</summary>

  1. ES6 解构：`[a, b] = [b, a]`;

  ```js
  function swap(a, b) {
    a = a + b;
    b = a - b;
    a = a - b;
  }

  function swap(a, b) {
    a = a * b;
    b = a / b;
    a = a / b;
  }

  function swap(a, b) {
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
  }
  ```
</details>

<details>
  <summary>原生事件不移除为什么会内存泄露</summary>
</details>

<details>
  <summary>bind / call / apply 的区别</summary>

  `call` 和 `apply` 功能相同，区别在于传参方式不同。
  1. `fn.call(obj, arg1, arg2, ...)`， `call` 传参数列表，逗号隔开
  2. `fn.call(obj, [arg1, arg2, ...])`， `apply` 传参数数组

  `bind` 返回的是一个函数，函数柯里化的应用，而 `call/apply` 则是立即执行函数。

  #### call 实现
  ```js
  Function.prototype.call = function(context, ...args) {
    // 判断传入对象是否为 null
    if (!context) {
      context = typeof window === 'undefined' ? global : window;
    }
    
    // 改变函数调用者，作为传入对象的属性方法调用
    context.fn = this;
    const result = context.fn(...args);
    delete context.fn;
    return result;
  }
  ```

  #### apply 实现
  ```js
  Function.prototype.call = function(context, ...args) {
    // 判断传入对象是否为 null
    if (!context) {
      context = typeof window === 'undefined' ? global : window;
    }
    
    // 改变函数调用者，作为传入对象的属性方法调用
    context.fn = this;
    const result = context.fn(args);
    delete context.fn;
    return result;
  }
  ```

  #### bind 实现
  ```js
  Function.prototype.bind = function(context, ...initArgs) {
    // 预先判断是否为函数
    if (typeof this !=== 'function') {
      throw new TypeError('no a function');
    }

    const self = this;
    // 返回一个待执行函数
    return function(...finalArgs) {
      // 合并预先传入的参数、最后传入的参数
      self.apply(context, [...initArgs, ...finalArgs]);
    }
  }
  ```

</details>

<details>
  <summary>async / await 的实现原理</summary>
</details>

<details>
  <summary>promise 与 async 的区别</summary>
</details>

<details>
  <summary>async 中多个 await 请求，如何优化（是否有依赖）</summary>
</details>

<details>
  <summary>实现localStorage, 保证数据的实效性</summary>
</details>

<details> 
  <summary>Promise 的状态</summary>

  1. `pending` 初始状态
  2. `fulfilled` 操作已完成
  3. `rejected` 操作已失败

</details>

<details>
  <summary>设计 Promise.all</summary>
</details>

<details>
  <summary>设计 Promise.finally </summary>
  
</details>

<details>
  <summary>如何比较两个对象</summary>

  工具类：借用 Immutable 对比两个对象。

  辅助函数，迭代对象属性，值为原始类型，则比对值，为引用类型，则继续递归跌打比对。注意函数、日期以及正则等。

</details>

<details>
  <summary>防抖 throttle 和节流 debounce 的区别</summary>

  * 同：两者的作用都是防止一定事件内函数被多次调用。
  * 异：
    * 防抖：在事件被触发 n 秒后再执行回调函数，如果在这 n 秒内又被触发，则重新计时延迟时间，例：R 大招 60 秒;
    * 节流：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效（间隔执行），例：FPS射击;
  * 应用：
    * 防抖：resize/scroll、文本验证等;
    * 节流：拖拽 mousemove、联想 keyup、监听滚动 scroll等;
</details>

<details>
  <summary>JavaScript 的回收机制是什么，常用的是哪种，怎么处理</summary>
  
  标记清除和引用计数，常用为手动标记清除，将变量值设置为 `null`。
</details>

<details>
  <summary>垃圾回收时堆和栈的区别</summary>
</details>

<details>
  <summary>手写数组去重函数 uniq</summary>

  ```js
  uniq([1, 2, 3, 5, 3, 2]);//[1, 2, 3, 5]
  ```

  #### 1. ES6 新增数据类型 set
  ```
  function uniq(arr) {
    return [...new Set(arr)];
  }
  ```

  #### 2. indexOf
  ```js
  function uniq(arr) {
    let result = [];
    for (let val of arr) {
      if (result.indexOf(val) < 0) {
        result.push(val);
      }
    }
    return result;
  }
  ```

  #### 3. includes
  ```js
  function uniq(arr) {
    let result = [];
    for (let val of arr) {
      if (!result.includes(val)) {
        result.push(val);
      }
    }
  }
  ```

  #### 4. reduce
  ```js
  function uniq(arr) {
    return arr.reduce([prev, cur] => {
      if (prev.includes(cur)) {
        return prev;
      } else {
        return [...prev, cur]
      }
    }, []);
  }
  ```

  #### 5. map 或 object[val]
  ```js
  function uniq(arr) {
    let map = new Map();
    let result = [];
    for (let val of arr) {
      if (!map.has(val)) {
        result.push(val);
        map.set(val, true);
      }
    }
    return result;
  }
  ```

</details>

<details>
  <summary>手写数组扁平化函数</summary>

  ```js
  flattenDeep([1, [2, [3, [4]], 5]]); //[1, 2, 3, 4, 5]
  ```

  #### 1. ES6 新增的 Array.prototype.flat
  ```js
  // flat 默认拉平一层
  function flattenDeep(arr, deepLength = 1) {
    return arr.flat(deepLength);
  }
  flattenDeep([1, [2, [3, [4]], 5]], 3); 
  ```

</details>

<details>
  <summary>new 实现原理 / 手写 new 实现</summary>

  1. 创建一个空对象 `{}`，构造函数的 `this` 指向这个空对象；
  2. 对该对象进行原型链接，`__proto__` 指向函数的 `prototype`；
  3. 执行构造函数方法，将属性添加到 `this` 指向的对象；
  4. 若函数没有返回其它值，则返回 `this` 指向的对象，若返回基本类型值，则返回它们的包装对象

  ```js
  function _new() {
    let target = {};
    let [constructor, ...args] = [...arguments];
    target.__proto__ = constructor.prototype;
    let result = constructor.apply(target, args);

    if (result && (typeof result == 'object' || typeof result == 'function') ) {
      return result;
    }
    return target;
  }
  ```

</details>

<details>
  <summary>字面量创建对象和 new Object 对比</summary>

  1. 字面量创建对象，不会调用 `Object` 构造函数，简洁性能更佳；
  2. `new Object()` 本质上是方法调用，会涉及到原型链查找，函数调用涉及到执行栈等

</details>

<details>
  <summary>异步加载 JS 脚本的方式</summary>

  1. defer 页面文档加载完执行，顺序执行，onLoad 之前执行
  2. async 下载完执行，顺序不定，会中断渲染
  3. 动态创建 script
  4. XHR 异步加载 JS

  ```js
  // 动态创建 script
  let script = document.createElement('script');
  script.src = 'xxx.js';
  document.body.append(script); // 添加到body才会执行

  // XHR 异步加载 JS + eval
  let xhr = new XMLHttpRequest();
  xhr.open('get', 'js/xxx.js', true);
  xhr.send();
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
      eval(xhr.responseText);
    }
  }
  ```

</details>

### 网络相关
<details>
  <summary>介绍同源策略</summary>
  
  浏览器同源策略限制不同源文档脚本不能进行交互。
  同源：同协议，同域名，同端口
</details>

<details>
  <summary>前端跨域方案 / 表单可以跨域吗？/ 有无使用过 Apache 方案</summary>
  
  后端接口请求不存在跨域问题，只有前端浏览器同源（同协议，同域名，同端口）限制导致跨域问题。

  1. JSONP：利用 script 标签的 src 属性来实现跨域，仅支持 GET 请求，url 长度限制；
  2. websocket：
  3. Nginx 反向代理；
  4. fetch
  5. CORS：兼容性 IE10 +
  ？？？
</details>

<details>
  <summary>什么是 CORS</summary>

  CORS （Cros-Origin Resource Sharing，跨域资源共享），额外的 HTTP 头授权浏览器访问跨域资源的机制
  ？？？
  <!-- 浏览器同源策略的限制，使得 XMLHttpRequest / fetch 不得跨域请求。 -->
</details>

<details>
  <summary>输入 URL 到页面加载的过程</summary>
</details>

<details>
  <summary>cookie, localStorage, sessionStorage</summary>

  * cookie：大小 4 K，请求在请求头携带，占用带宽，初衷是解决 HTTP 无状态，服务端可共享，可设置过期时间；
  * localStorage/sessiongStorage：大小 5 M，数据只保留本地，不参与服务端交互；
    * localStorage：永久存在，需手动清除；
    * sessionStorage：仅存在会话中，tab 关闭就实效；
    
</details>

<details>
  <summary>cookie 和 token 都存放在 header 中，为何只劫持前者</summary>
</details>

<details>
  <summary>HTTP 报文</summary>
</details>

<details>
  <summary>HTTP 请求头</summary>
</details>

<details>
  <summary>HTTP 状态码</summary>
</details>

<details>
  <summary>TCP 属于哪一层</summary>

  TCP 属于 OSI 的传输层，通讯过程是全双工

</details>

<details>
  <summary>网络（TCP/IP）的五层模型</summary>
  
  1. 应用层（DNS)[传输、表示、应用]
  2. 传输层
  3. 网络层
  4. 数据链路层
  5. 物理层

</details>

<details>
  <summary>TCP 与 UDP 的区别</summary>

  1. TCP 面向链接，UDP 无连接，即发送数据之前不需要建立链接；
  2. TCP 提供可靠的服务，无差错、不丢失、不重复、且按序到达，UDP 不保证可靠支付；
  3. TCP 面向字节流，UDP 面向报文；
  4. TCP 是点对点，UDP 支持一对一，一对多，多对一和多对多；
  5. TCP 首部开心 20 字节，UDP 首部 8字节；
  6. TCP 逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道

</details>

<details>
  <summary>HTTP/HTTPS 的区别</summary>
</details>

### React
<details>
  <summary> React 生命周期 </summary>

  > 版本：16.8
  
  生命周期阶段：
  1. 挂载阶段
  2. 更新阶段
  3. 卸载阶段

  #### 挂载阶段
  | -- | -- |
  * constructor 
  构造函数，最先执行，初始化 state 或函数 this 绑定

  * getDerivedStateFromProps
  静态方法，接收到新属性 props 修改 state 时触发

  * render
  纯函数，处理渲染，不应包含业务逻辑或计算，返回：原生 Dom、React 组件、字符串/数字、布尔/null等

  * componentDidMount
  组件挂载完成，已获取到 DOM 节点，在在此处理：请求、订阅等（订阅配套要在 componentWillUnmount 取消）

  #### 更新阶段
  * getDerivedStateFromProps

  * shouldComponentUpdate(nextProps, nextState) 
  返回一个布尔值，ture（默认）表示重新渲染，false 反之。（在此做优化）

  * render

  * getSnapshotBeforeUpdate(prevProps, prevState)
  返回一个值给 componentDidUpdate，DOM元素状态的对比/计算

  * componentDidUpdate(prevProps, prevState, snapshot)


  #### 卸载阶段
  * componentWillUnmount
  组件卸载或销毁时调用，（定时器销毁、取消网络请求、订阅等）

  #### 请求放置在哪个生命周期
  **componentDidMount**

  > 为何不是 componentWillMount 做数据请求

  * 服务端渲染时，会执行两次，一次在服务端，一次在客户端
  * 16版本的fiber重写后，会多次调用
  * JS 异步机制不会等待 componentWillMount 完成后再 render
  
</details>

<details>
  <summary>setState 是是同步还是同步 </summary>

  * 异步：合成事件和钩子函数（可批量更新 `state`)
  * 同步：原生事件和 `setTimeout` 中（不可批量更新）

  `setState` 本身执行过程和代码都是同步，只是合成事件和钩子函数的调用更新钱，无法立马拿到更新后的值，形成“异步”，需借助 `setState(callback)` 中 `callback` 来拿到。

  批量更新 `state` 的优化也是借助于此，多次更新 `state`,会取最后一次执行，同时 `setState` 多个不同 `key` 值，会合并更新。
</details>

<details>
  <summary>React 组件通信方式</summary>

  * 父子组件通信：`props` 传递；
  * 兄弟组件通信：状态提升到共有父组件，由父组件管控转发属性；
  * 跨层级通信：`context` （组件树传递）；
  * 发布订阅模式（事件总线）：`Event` 模块，发布者发布事件，订阅者监听事件并做出反馈；
  * 全局状态管理：redux/mbox，维护全局 `store`
</details>

<details>
  <summary>React 组件/逻辑复用</summary>

  * HOC 高阶组件 （组件包含来实现）
  缺点：
    1. 扩展性：HOC 无法从外部访问子组件的 `state`，因此无法通过 `shouldComponentUpdate` 过滤，可采用 `PureComponent` 来解决；
    2. Ref 传递：需借助 `React.forwardRef` 来解决
    3. 嵌套包装：增加复杂度和理解成本，命名冲突等

  * Render Props 渲染属性
  缺点：解决来 HOC 组件嵌套问题，换成来函数回调的嵌套

  * 自定义 Hooks
  优点：
    1. 简洁：解决 HOC 和 Render Props 的嵌套问题
    2. 解耦：UI 与 逻辑分离，彻底解耦
    3. 组合：Hooks 可引用其它 Hooks，多样化组合使用
    4. 对函数组件友好，
      * 不同生命周期逻辑维护更简单
      * 解决 `this` 指向
      * 复用成本与理解降低
  
  缺点：
    1. 写法限制：不能出现在条件、循环中
    2. 破话 `PureComponent`、`React.memo` 的性能优化
    3. `React.memo` 不能完全替代 `ShouldComponentUpdate`，只比对 `props`
  
</details>

<details>
  <summary>Redux 和全局变量（window)的区别 </summary>
</details>

<details>
  <summary>解决 props 层级过深的问题</summary>

  借用 Imuteable 不可变数据，解决。
</details>

<details>
  <summary>Base64为什么能提升性能，优缺点</summary>

  1. 减少 HTPP 请求，代价是 CSS 文件体积过大
  2. 极小图片
  3. 无跨域问题，无需考虑缓存、文件头或 cookie 问题
  4. 比 16 进制更节省磁盘容量

</details>

### Vue


### 设计模式
<details>
  <summary>观察者和订阅-发布的区别，各自应用</summary>
</details>

