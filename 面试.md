### CSS 相关

<details>
  <summary>CSS 选择器有哪些</summary>

  分类可分三种：基本选择器、属性选择器、伪类选择器
  常用：class/id/伪类/伪元素/属性

</details>

<details>
  <summary>盒子模型</summary>

  | 盒子模型 | 宽度计算 | CSS 设置 |
  | -- | -- |
  | 标准 | `width = content-width` | box-sizing: content-box |
  | IE | `width = content-width + padding-width + border-width` | box-sizing: border-box |

</details>

<details>
  <summary>移动端适配 1px  问题</summary>
</details>

<details>
  <summary> b 和 strong 的区别 </summary>

  两者都有加粗字体的作用，但 strong 带有语义，表示强调，利于SEO。

</details>

<details>
  <summary>三栏布局/圣杯布局/双飞翼布局方式</summary>

  | 布局 | 优缺点 |
  | -- | -- |
  | float 浮动 | 脱离文档流，需清浮解决父层高度塌陷 |
  | absoulute 绝对定位 | 自身跟后代元素都脱离文档流，需定高 |
  | table 表格 | 兼容性好，高度统一撑开，无法设置边距，SEO不友好 |
  | flex | 较完美，IE10开始支持（-ms) |
  | grid 网格 | IE10+支持，没有内容结构，子元素可自行定义位置 |

  #### 1. float 浮动布局
  **`DOM` 结构先写浮动部分，再写中间，否则右浮动会掉到下一行**

  * 优点：简单，兼容性好
  * 缺点：脱离文档流，父层高度塌陷需清浮解决

  ```html
  <article>
      <div class="left red"></div>
      <div class="right blue"></div>
      <div class="center yellow"></div>
  </article

  <style>
      .left {
          float: left;
          width: 300px;
      }
      .right {
          float: right;
          width: 300px;
      }
  </style>
  ```
  #### 2. absoulute 绝对定位布局
  * 优点：方便稳定
  * 脱离文档流，后代元素也脱离文档流，高度未知时，会有问题

  ```html
  <article>
    <div class="left red"></div>
    <div class="center yellow"></div>
    <div class="right blue"></div>
  </article>

  <style>
    article {
        position: relative;
    }
    article div {
        position: absolute;
    }
    .left {
        left: 0;
        width: 300px;
    }
    .right {
        right: 0;
        width: 300px;
    }
    .center {
        left: 300px;
        right: 300px;
    }
  </style>
  ```

  #### 3. table 表格布局
  * 优点：兼容性好
  * 缺点：
      * 无法设置栏边距；
      * 对 SEO 不友好；
      * 单元格高度超出时，两侧单元格高度会一并变高；
      
  ```html
  <article>
      <div class="left red"></div>
      <div class="center yellow"></div>
      <div class="right blue"></div>
  </article>

  <style>
      article {
          display: table;
      }
      article > div {
          display: table-cell;
      }
      .left, .right {
          width: 300px;
      }
  </style>
  ```
  #### 4. flex 布局
  * 优点：比较完美
  * 缺点：低版本浏览器兼容问题，IE10开始支持（-ms)

  ```html
  <article>
      <div class="left red"></div>
      <div class="center yellow"></div>
      <div class="right blue"></div>
  </article>

  <style>
      article {
          display: flex;
      }
      .left, .right {
          width: 300px;
      }
      .center {
          flex: 1;
      }
  </style>
  ```

  #### 5. grid 网格布局

  CSS3 推出的网格布局，按列或行对其排列，不同于表格，没有内容结构。子元素可定位自己的位置，可以重叠（IE10+支持）。

  ```
  article {
      display: grid;
      grid-template-columns: 300px auto 300px;
  }
  ```
</details>

<details>
  <summary>rem 与 flex 的区别</summary>
</details>

<details>
  <summary>em 与 px 的区别</summary>
</details>

<details>
  <summary>CSS3 position 新增支持 / position: sticky</summary>

  | 属性 | 作用 |
  | -- | -- |
  | static | 没有定位（默认 |
  | relative | 相对定位 | 
  | absolute | 绝对定位 |
  | fixed | 固定定位（相对body) |
  | sticky | 粘滞定位 | 

  1. absolute 会被 relative/absolute 的父元素限制，否则被 body
  2. stick 是 relative 和 fixed 的混合体
    * 元素在视口内，top/left 无效；
    * 滚动超出时，表现像 fixed；
    * left/right 同时设置保留前者，top/bottom 同理

</details>

<details>
  <summary>CSS 水平垂直居中的方式</summary>

  居中元素固定宽高：
  1. absolute + 负 margin
  2. absolute + margin auto
  3. absolute + calc

  居中元素不定宽：
  1. absolute + transform（移动端优先）
  2. line-height
  3. writing-mode
  4. table (可弃用)
  5. css-table
  6. flex（优先）
  7. grid

</details>

<details>
  <summary>居中为何优先使用 transform （而不用 margin/top)</summary>

  支持居中元素不用定宽，不用计算宽高减半值。

</details>

### JavaScript 相关
<details>
  <summary>判断变量是不是数组</summary>

  1. `Array.isArray()` 返回 `true` 是；
  2. `instanceof Array` 返回 `true` 是；
  3. `Object.prototype.toString.call()` 值为 `[object Array]` 是

</details>

<details>
  <summary>类数组和数组的区别</summary>

  类数组是一个普通对象，有 length 属性，而真实的数组是 Array 类型，且不具备数组的方法。

  常见类数组：
  1. 函数参数 arguments
  2. DOM 对象列表 document.querySelectorAll('li')
  3. jQuery 对象 $('div')

  类数组转数组：
  ```
  // e.g.1
  Array.prototype.slice.call(arrLike);

  // e.g.2
  [...arrLike];

  // e.g.3
  Array.from(arrLike); 
  ```

  拥有遍历器接口的对象，都可用扩展运算符和 Array.from 转为数组。

</details>

<details>
  <summary>for...in 和 Object.keys() 的区别</summary>

  1. `Object.keys()` 返回自身可枚举属性组成的数组，顺序与 `for...in` 一致；
  2. `for...in` 除了遍历自身可枚举，还可以枚举原型链中属性

  记忆点：与 in 有关都会检索原型链
</details>

<details>
  <summary>实现 this 对象的深拷贝</summary>
</details>

<details>
  <summary>浏览器事件流向</summary>
</details>

<details>
  <summary>事件代理以及优缺点</summary>
</details>

<details>
  <summary>闭包特权函数的使用场景</summary>
</details>

<details>
  <summary>尾调用优化</summary>
</details>

<details>
  <summary>函数参数是按值传递还是按引用传递</summary>

  函数参数是按值传递，引用类型的值是其栈中存储的值，一个地址指针。
</details>

<details>
  <summary>defineProperty 的应用场景</summary>
</details>

<details>
  <summary> setInterval 的注意点 </summary>
</details>

<details>
  <summary> setTimeout(1) 和 setTimeout(2) 的区别 </summary>
</details>

<details>
  <summary>实现继承的方案</summary>
</details>

<details>
  <summary>变量 a, b 如何交换值</summary>

  ES6 解构：`[a, b] = [b, a]`;
</details>

<details>
  <summary>原生事件不移除为什么会内存泄露</summary>
</details>

<details>
  <summary>bind / call / apply 的区别</summary>

  call 和 apply 功能相同，区别在于传参方式不同。
  1. `fn.call(obj, arg1, arg2, ...)` call 传参数列表，逗号隔开
  2. `fn.call(obj, [arg1, arg2, ...]) apply 传参数数组

  bind 返回的是一个函数，函数柯里化的应用，而 call/apply 则是立即执行函数。

</details>

<details>
  <summary>async / await 的实现原理</summary>
</details>

<details>
  <summary> promise 与 async 的区别 </summary>
</details>

<details>
  <summary> async 中多个 await 请求，如何优化（是否有依赖）</summary>
</details>

<details>
  <summary> 实现localStorage, 保证数据的实效性 </summary>
</details>

<details>
  <summary> 设计 Promise.all</summary>
</details>

<details>
  <summary> 如何比较两个对象 </summary>
</details>

<details>
  <summary>防抖和节流的区别</summary>
</details>

<details>
  <summary>JavaScript 的回收机制是什么，常用的是哪种，怎么处理</summary>
  
  标记清除和引用计数，手动标记清除，将变量值设置为 `null`。
</details>

<details>
  <summary>垃圾回收时堆和栈的区别</summary>
</details>

<details>
  <summary>手写数组去重函数</summary>
</details>

<details>
  <summary>手写数组扁平化函数</summary>
</details>

<details>
  <summary>new 实现原理 / 手写 new 实现</summary>
</details>

### 网络相关
<details>
  <summary>介绍同源策略</summary>
  
  浏览器同源策略限制不同源文档脚本不能进行交互。
  同源：同协议，同域名，同端口
</details>

<details>
  <summary>前端跨域方案 / 表单可以跨域吗？/ 有无使用过 Apache 方案</summary>
  
  后端接口请求不存在跨域问题，只有前端浏览器同源（同协议，同域名，同端口）限制导致跨域问题。

  1. JSONP
  2. websocket
  3. Nginx 代理
  4. fetch

</details>

<details>
  <summary>输入 URL 到页面加载的过程</summary>
</details>

<details>
  <summary>cookie, localStorage, sessionStorage</summary>
</details>

<details>
  <summary> cookie 和 token 都存放在 header 中，为何只劫持前者</summary>
</details>

<details>
  <summary> HTTP 报文 </summary>
</details>

<details>
  <summary> HTTP 请求头 </summary>
</details>

<details>
  <summary> HTTP 状态码 </summary>
</details>

<details>
  <summary> TCP 属于哪一层</summary>
</details>

<details>
  <summary> 网络的五层模型 </summary>
</details>

<details>
  <summary> HTTP/HTTPS 的区别 </summary>
</details>

<details>
  <summary></summary>
</details>

### React
<details>
  <summary> React 生命周期 </summary>
</details>

<details>
  <summary> setState 什么时候是同步的 </summary>
</details>

<details>
  <summary>Redux 和全局变量（window)的区别 </summary>
</details>


<details>
  <summary>解决 props 层级过深的问题</summary>
</details>

<details>
  <summary>Base64为什么能提升性能，优缺点</summary>
</details>

### Vue


### 设计模式
<details>
  <summary>观察者和订阅-发布的区别，各自应用</summary>
</details>

